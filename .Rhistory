#result of two blocks:
set.seed(12345)
plot(karate, vertex.size=15, vertex.color=Kclass2$best$best1$clu, asp=0)
title("Two Block Partition")
#result of three blocks:
set.seed(12345)
plot(karate, vertex.size=15, vertex.color=Kclass3$best$best1$clu, asp=0)
title("Three Block Partition")
#result of four blocks:
set.seed(12345)
plot(karate, vertex.size=15, vertex.color=Kclass4$best$best1$clu, asp=0)
title("Four Block Partition")
#result of two blocks:
set.seed(12345)
plot(karate, vertex.size=15, vertex.color=Kclass2$best$best1$clu, asp=0)
title("Two Block Partition")
#result of three blocks:
set.seed(12345)
plot(karate, vertex.size=15, vertex.color=Kclass3$best$best1$clu, asp=0)
title("Three Block Partition")
#result of four blocks:
set.seed(12345)
plot(karate, vertex.size=15, vertex.color=Kclass4$best$best1$clu, asp=0)
title("Four Block Partition")
par(mfrow=c(1,3))
#result of two blocks:
set.seed(12345)
plot(karate, vertex.size=15, vertex.color=Kclass2$best$best1$clu, asp=0)
title("Two Block Partition")
#result of three blocks:
set.seed(12345)
plot(karate, vertex.size=15, vertex.color=Kclass3$best$best1$clu, asp=0)
title("Three Block Partition")
#result of four blocks:
set.seed(12345)
plot(karate, vertex.size=15, vertex.color=Kclass4$best$best1$clu, asp=0)
title("Four Block Partition")
l <- layout_with_fr(karate) #creating one layout and saving it as object "l".
par(mfrow=c(1,3))
#result of two blocks:
plot(karate, vertex.size=15, vertex.color=Kclass2$best$best1$clu, layout = l, asp=0)
title("Two Block Partition")
#result of three blocks:
plot(karate, vertex.size=15, vertex.color=Kclass3$best$best1$clu, layout = l, asp=0)
title("Three Block Partition")
#result of four blocks:
plot(karate, vertex.size=15, vertex.color=Kclass4$best$best1$clu, layout = l, asp=0)
title("Four Block Partition")
N <- read.csv("data/net_anon24.csv", header = TRUE)
c <- read.csv("data/courses24.csv", header = TRUE)
#selecting and ordering courses according tho the node order and set in V(gn)
c <- (c[as.numeric((V(gn)$name)),])
gn <- graph.data.frame(N, directed = TRUE) + vertices(25, 16, 34, 64, 99, 54, 113)
#selecting and ordering courses according tho the node order and set in V(gn)
c <- c[as.numeric((V(gn)$name)),]
View(c)
c <- read.csv("data/courses24.csv", header = TRUE)
View(c)
#selecting and ordering courses according tho the node order and set in V(gn)
c <- c[as.numeric((V(gn)$name)),]
gn <- set_vertex_attr(gn, "course", value = c$course)
lc <- largest_cliques(gn)
lc
lc <- largest_cliques(gn)
lc
V(gn)$clique <- ifelse(V(gn) %in% c(largest_cliques(gn)[[1]]), 1, 0)
lf <-layout.fruchterman.reingold(gn)
V(gn)$clique <- ifelse(V(gn) %in% c(largest_cliques(gn)[[1]]), 1, 0)
lf <-layout.fruchterman.reingold(gn)
plot(gn,
vertex.size= 2,
edge.arrow.size = 0.3,
vertex.label.cex = 0.7,
edge.curved=.2, asp = 0,
layout = lf,
vertex.label.dist=0.7,
vertex.color = V(gn)$clique,
main = "Largest clique in SOCS0081")
lf <-layout.fruchterman.reingold(gn)
V(gn)$clique <- ifelse(V(gn) %in% c(largest_cliques(gn)[[1]]), 1, 0)
plot(gn,
vertex.size= 2,
edge.arrow.size = 0.3,
vertex.label.cex = 0.7,
edge.curved=.2, asp = 0,
layout = lf,
vertex.label.dist=0.7,
vertex.color = V(gn)$clique,
main = "Largest clique in SOCS0081")
set.seed(1)
lf <-layout.fruchterman.reingold(gn)
V(gn)$clique <- ifelse(V(gn) %in% c(largest_cliques(gn)[[1]]), 1, 0)
plot(gn,
vertex.size= 2,
edge.arrow.size = 0.3,
vertex.label.cex = 0.7,
edge.curved=.2, asp = 0,
layout = lf,
vertex.label.dist=0.7,
vertex.color = V(gn)$clique,
main = "Largest clique in SOCS0081")
print(cliques(gn, min = 5, max = 100))
V(gn)$clique5 <- ifelse(V(gn) %in% unlist(cliques(gn, min = 5, max = 100)), 1, 0)
#we are using the unlist() function to extract all elements of list into a single vector
plot(gn,
vertex.size= 2,
edge.arrow.size = 0.3,
vertex.label.cex = 0.7,
edge.curved=.2, asp = 0,
layout = lf,
vertex.label.dist=0.7,
vertex.color = V(gn)$clique5,
main = "Cliques of size 5 or more in SOCS0081")
coreness(gn)
table(coreness(gn))
coreness(gn)[coreness(gn) == max(coreness(gn))]
table(coreness(gn), V(gn)$course)
plot(gn,
vertex.size= 2,
edge.arrow.size = 0.3,
vertex.label.cex = 0.7,
edge.curved=.2,
asp = 0, layout = lf,
vertex.label.dist=0.7,
vertex.color =rainbow(8)[as.factor(coreness(gn))],
main = "Coreness in SOCS0081")
legend("topleft",
bty = "n",
legend=unique(as.factor(coreness(gn))),
cex = 0.7,
fill = rainbow(8)[unique(as.factor(coreness(gn)))]
)
MS <- as.matrix(gn) #turning gn network into a matrix needed for blockmodelling
c5 <- optRandomParC(M=MS, k=5, rep=10, approach="ss", blocks="com")
c6 <- optRandomParC(M=MS, k=6, rep=10, approach="ss", blocks="com")
c7 <- optRandomParC(M=MS, k=7, rep=10, approach="ss", blocks="com")
MS <- as.matrix(gn) #turning gn network into a matrix needed for blockmodelling
c5 <- optRandomParC(M=MS, k=5, rep=10, approach="ss", blocks="com")
MS <- as.matrix(gn) #turning gn network into a matrix needed for blockmodelling
c5 <- optRandomParC(M=MS, k=5, rep=10, approach="ss", blocks="com")
c6 <- optRandomParC(M=MS, k=6, rep=10, approach="ss", blocks="com")
c7 <- optRandomParC(M=MS, k=7, rep=10, approach="ss", blocks="com")
MS <- as.matrix(gn) #turning gn network into a matrix needed for blockmodelling
c5 <- optRandomParC(M=MS, k=5, rep=10, approach="ss", blocks="com")
c6 <- optRandomParC(M=MS, k=6, rep=10, approach="ss", blocks="com")
c7 <- optRandomParC(M=MS, k=7, rep=10, approach="ss", blocks="com")
plot(gn,
vertex.size= 2,
edge.arrow.size = 0.3,
vertex.label.cex = 0.7,
edge.curved=.2,
asp = 0, layout = lf,
vertex.label.dist=0.7,
vertex.color = c5$best$best1$clu,
main = "5 blocks of SOCS0081",
margin=c(0,0,0,0))
plot(gn,
vertex.size= 2,
edge.arrow.size = 0.3,
vertex.label.cex = 0.7,
edge.curved=.2,
asp = 0, layout = lf,
vertex.label.dist=0.7,
vertex.color = c6$best$best1$clu,
main = "6 blocks of SOCS0081",
margin=c(0,0,0,0))
plot(gn,
vertex.size= 2,
edge.arrow.size = 0.3,
vertex.label.cex = 0.7,
edge.curved=.2,
asp = 0, layout = lf,
vertex.label.dist=0.7,
vertex.color = c7$best$best1$clu,
main = "7 blocks of SOCS0081",
margin=c(0,0,0,0))
View(c5)
table(c5$best$best1$clu, V(gn)$course)
chisq.test(table(c5$best$best1$clu, V(gn)$course))
g.1 <- graph( c(1,2,2,1,1,3,3,1,2,4,4,2,3,4,4,1))
library(igraph)
g.1 <- graph( c(1,2,2,1,1,3,3,1,2,4,4,2,3,4,4,1))
plot(g.1, edge.curved=.2, layout=layout.circle)
g.1 <- graph(c(1,2,2,1,1,3,3,1,2,4,4,2,3,4,4,1))
plot(g.1, edge.curved=.2, layout=layout.circle)
reciprocity(g.1)
g.2 <- graph( c(2,1, 3,1, 4,1, 5,1, 3,4, 4,5), directed = FALSE)
plot(g.2, layout=layout.star)
transitivity(g.2, type="local", isolates = "zero")
transitivity(g.2, type="global")
M <- matrix(1, nrow = 5, ncol = 5) #adjacency matrix of the network: all 1's, complete network
diag(M) <- 0 #replacing diagonals with 0 as no self-edges are allowed.
g.3 <- graph_from_adjacency_matrix(M, mode = "undirected")
plot(g.3, layout = layout.circle,
edge.label = c("+", "+", "-", "-", "+", "-", "-", "-", "-", "+"), #labels of the edges
edge.label.cex=2, edge.label.font = 2) #cosmetic stuff
N <- readRDS("data/so2001.rds")
set.seed(123456789)
plot.igraph(N, edge.color="gray",edge.width=0.3,
vertex.size = 0,
vertex.label.cex=0.6,  margin=c(0,0,0,0) , asp=0, main = "2001: A Space Odyssey")
transitivity(N)
round(transitivity(N), digits = 2)
round(transitivity(N, type="local"), digits = 3)
cbind(V(N)$name, round(transitivity(N, type = "local"), digits = 2))
T <- transitivity(N, type="local")
B <- betweenness(N)
plot(T, B, xlab="Local clustering", ylab="Betweenness")
abline(lm(B ~ T))
text(0.8, 100, paste("Correlation:", round(cor(T,B),2)))
text(T, B, labels=V(N)$name,cex=0.4, font=2, pos=1)
N <- read.csv("data/net_anon24.csv", header = TRUE)
c <- read.csv("data/courses24.csv", header = TRUE)
gn <- graph.data.frame(N, directed = TRUE) + vertices(25, 16, 34, 64, 99, 54, 113)
gn <- set_vertex_attr(gn, "course", value = c[as.numeric((V(gn)$name)),]$course)
set.seed(1)
lf <-layout.fruchterman.reingold(gn)
plot(gn,
vertex.size= 2,
edge.arrow.size = 0.3,
vertex.label.cex = 0.7,
edge.curved=.2,
asp = 0, layout = lf,
vertex.label.dist=0.7,
vertex.color = rainbow(4)[as.factor(V(gn)$course)],
main = "Network of SOCS0081")
text(-1, -1, paste("Global clustering:", round(transitivity(gn),3) )) # adding global clustering on the plot
legend("topleft",
bty = "n",
legend=unique(as.factor(V(gn)$course)),
cex = 0.7,
fill = rainbow(4)[unique(as.factor(V(gn)$course))])
plot(transitivity(gn, type = "local", isolates = "NaN"),
betweenness(gn, normalized = TRUE),
main = "Local clustering and betweenness centrality in SOCS0081")
abline(lm(betweenness(gn, normalized = TRUE) ~ transitivity(gn, type = "local", isolates = "NaN") ))
text(0.8, 0.1, paste("Correlation:",
round(cor(transitivity(gn, type = "local", isolates = "NaN"),
betweenness(gn, normalized = TRUE),
use = "na.or.complete"),2)))
text(transitivity(gn, type = "local", isolates = "NaN"),
betweenness(gn, normalized = TRUE),
labels=V(gn)$name,cex=0.7, font=2, pos=2)
?aggregate
mtr <- aggregate(x=transitivity(gn, type = "local",
isolates = "zero"),
by= list(as.factor(V(gn)$course)),
FUN=mean)
View(mtr)
mtr <- aggregate(x = transitivity(gn, type = "local", isolates = "zero"),
by = list(as.factor(V(gn)$course)),
FUN=mean)
barplot(height  = mtr[,2], names.arg = mtr[,1],
xlab="Course",
ylab="Avg local clustering",
main = "Local clustering across courses")
summary(lm(transitivity(gn, type = "local", isolates = "zero") ~ as.factor(V(gn)$course)))
reciprocity(gn)
mean_distance(gn, directed = TRUE, unconnected = TRUE)
library(igraph)
library(igraphdata)
N <- read.csv("data/net_anon24.csv", header = TRUE)
c <- read.csv("data/courses24.csv", header = TRUE)
g <- graph.data.frame(N, directed = FALSE) +
vertices(25, 16, 34, 64, 99, 54, 113)
g <- set_vertex_attr(g, "course", value = c[as.numeric((V(g)$name)),]$course)
N <- read.csv("data/net_anon24.csv", header = TRUE)
c <- read.csv("data/courses24.csv", header = TRUE)
g <- graph.data.frame(N, directed = FALSE) +
vertices(25, 16, 34, 64, 99, 54, 113)
g <- set_vertex_attr(g, "course", value = c[as.numeric((V(g)$name)),]$course)
set.seed(1)
lf <-layout.fruchterman.reingold(g)
plot(g, vertex.size= 2, edge.arrow.size = 0.3,  vertex.label.cex = 0.7,
edge.curved=.2, asp = 0, layout = lf, vertex.label.dist=0.7,
vertex.color = rainbow(4)[as.factor(V(g)$course)], main = "Undirected network of SOCS0081")
library(igraph)
library(igraphdata)
N <- read.csv("data/net_anon24.csv", header = TRUE)
c <- read.csv("data/courses24.csv", header = TRUE)
g <- graph.data.frame(N, directed = FALSE) +
vertices(25, 16, 34, 64, 99, 54, 113)
g <- set_vertex_attr(g, "course", value = c[as.numeric((V(g)$name)),]$course)
set.seed(1)
lf <-layout.fruchterman.reingold(g)
plot(g, vertex.size= 2, edge.arrow.size = 0.3,  vertex.label.cex = 0.7,
edge.curved=.2, asp = 0, layout = lf, vertex.label.dist=0.7,
vertex.color = rainbow(4)[as.factor(V(g)$course)], main = "Undirected network of SOCS0081")
mean(degree(g))
mean_distance(g, directed = FALSE, unconnected = TRUE)
c/(n-1)
library(igraph)
library(igraphdata)
N <- read.csv("data/net_anon24.csv", header = TRUE)
c <- read.csv("data/courses24.csv", header = TRUE)
g <- graph.data.frame(N, directed = FALSE) +
vertices(25, 16, 34, 64, 99, 54, 113)
g <- set_vertex_attr(g, "course", value = c[as.numeric((V(g)$name)),]$course)
set.seed(1)
lf <-layout.fruchterman.reingold(g)
plot(g, vertex.size= 2, edge.arrow.size = 0.3,  vertex.label.cex = 0.7,
edge.curved=.2, asp = 0, layout = lf, vertex.label.dist=0.7,
vertex.color = rainbow(4)[as.factor(V(g)$course)], main = "Undirected network of SOCS0081")
mean(degree(g))
mean_distance(g, directed = FALSE, unconnected = TRUE)
transitivity(g)
n <- length(V(g))
n
c/(n-1)
library(igraph)
library(igraphdata)
N <- read.csv("data/net_anon24.csv", header = TRUE)
c <- read.csv("data/courses24.csv", header = TRUE)
g <- graph.data.frame(N, directed = FALSE) +
vertices(25, 16, 34, 64, 99, 54, 113)
g <- set_vertex_attr(g, "course", value = c[as.numeric((V(g)$name)),]$course)
set.seed(1)
lf <-layout.fruchterman.reingold(g)
plot(g, vertex.size= 2, edge.arrow.size = 0.3,  vertex.label.cex = 0.7,
edge.curved=.2, asp = 0, layout = lf, vertex.label.dist=0.7,
vertex.color = rainbow(4)[as.factor(V(g)$course)], main = "Undirected network of SOCS0081")
mean(degree(g))
mean_distance(g, directed = FALSE, unconnected = TRUE)
transitivity(g)
n <- length(V(g))
n
p <- c/(n-1)
n
class(n)
library(igraph)
library(igraphdata)
N <- read.csv("data/net_anon24.csv", header = TRUE)
c <- read.csv("data/courses24.csv", header = TRUE)
g <- graph.data.frame(N, directed = FALSE) +
vertices(25, 16, 34, 64, 99, 54, 113)
g <- set_vertex_attr(g, "course", value = c[as.numeric((V(g)$name)),]$course)
set.seed(1)
lf <-layout.fruchterman.reingold(g)
plot(g, vertex.size= 2, edge.arrow.size = 0.3,  vertex.label.cex = 0.7,
edge.curved=.2, asp = 0, layout = lf, vertex.label.dist=0.7,
vertex.color = rainbow(4)[as.factor(V(g)$course)], main = "Undirected network of SOCS0081")
c <- mean(degree(g))
c
mean_distance(g, directed = FALSE, unconnected = TRUE)
transitivity(g)
n <- length(V(g))
n
p <- c/(n-1)
p
g.r <- sample_gnp(n, p, directed = FALSE, loops = FALSE)
g.r <- sample_gnp(n, p, directed = FALSE, loops = FALSE)
mean(degree(g.r))
mean_distance(g.r, directed = FALSE, unconnected = FALSE)
transitivity(g.r)
set.seed(1)
g.r <- sample_gnp(n, p, directed = FALSE, loops = FALSE)
mean(degree(g.r))
mean_distance(g.r, directed = FALSE, unconnected = FALSE)
transitivity(g.r)
set.seed(100)
g.r <- sample_gnp(n, p, directed = FALSE, loops = FALSE)
mean(degree(g.r))
mean_distance(g.r, directed = FALSE, unconnected = FALSE)
transitivity(g.r)
M <- matrix(NA, nrow = 1000, ncol = 3)
colnames(M) <- c("degree", "distance", "clustering")
M <- matrix(NA, nrow = 1000, ncol = 3)
colnames(M) <- c("degree", "distance", "clustering")
View(N)
View(M)
for (i in 1:1000) {
g.r    <- sample_gnp(n, p, directed = FALSE, loops = FALSE)
M[i,1] <- mean(degree(g.r))
M[i,2] <- mean_distance(g.r, directed = FALSE, unconnected = TRUE)
M[i,3] <- transitivity(g.r)
}
par(mfrow=c(1,3))
library(igraph)
library(igraphdata)
N <- read.csv("data/net_anon24.csv", header = TRUE)
c <- read.csv("data/courses24.csv", header = TRUE)
g <- graph.data.frame(N, directed = FALSE) +
vertices(25, 16, 34, 64, 99, 54, 113)
g <- set_vertex_attr(g, "course", value = c[as.numeric((V(g)$name)),]$course)
set.seed(1)
lf <-layout.fruchterman.reingold(g)
plot(g, vertex.size= 2, edge.arrow.size = 0.3,  vertex.label.cex = 0.7,
edge.curved=.2, asp = 0, layout = lf, vertex.label.dist=0.7,
vertex.color = rainbow(4)[as.factor(V(g)$course)], main = "Undirected network of SOCS0081")
deg <- mean(degree(g))
deg
dist <- mean_distance(g, directed = FALSE, unconnected = TRUE)
dist
clustering <- transitivity(g)
clustering
n <- length(V(g))
n
p <- c/(n-1)
n <- length(V(g))
n
p <- c/(n-1)
p <- c/(n-1)
p
p <- deg/(n-1)
p
M <- matrix(NA, nrow = 1000, ncol = 3)
colnames(M) <- c("degree", "distance", "clustering")
for (i in 1:1000) {
g.r    <- sample_gnp(n, p, directed = FALSE, loops = FALSE)
M[i,1] <- mean(degree(g.r))
M[i,2] <- mean_distance(g.r, directed = FALSE, unconnected = TRUE)
M[i,3] <- transitivity(g.r)
}
par(mfrow=c(1,3))
hist(M[,1], main = "Histogram of mean degree")
abline(v = degree, col="red", lwd=3, lty=2)
M <- matrix(NA, nrow = 1000, ncol = 3)
colnames(M) <- c("degree", "distance", "clustering")
for (i in 1:1000) {
g.r    <- sample_gnp(n, p, directed = FALSE, loops = FALSE)
M[i,1] <- mean(degree(g.r))
M[i,2] <- mean_distance(g.r, directed = FALSE, unconnected = TRUE)
M[i,3] <- transitivity(g.r)
}
par(mfrow=c(1,3))
hist(M[,1], main = "Histogram of mean degree")
abline(v = deg, col="red", lwd=3, lty=2)
hist(M[,2], xlim = c(2.5,4.2), main = "Histogram of mean distance")
abline(v = dist, col="red", lwd=3, lty=2)
hist(M[,3], xlim = c(0.02,0.4), main = "Histogram of Clustering coeff")
abline(v = clustering, col="red", lwd=3, lty=2)
sum(M[,1] > deg)/1000
sum(M[,2] > dist)/1000
sum(M[,3] > clustering)/1000
setwd("~/Documents/UCL/Year 3/Social_Networks_SOCS0081")
setwd("~/Documents/UCL/Year 3/Social_Networks_SOCS0081/Practicals - SOCS0081")
Version()
version()
R.Version()
?sample_smallworld
g.s <- sample_smallworld(dim = 1, # one dimension (all nodes are around a circle)
size = n,
nei = round(deg/2), # neighbourhood is c/2 in both ways so c in total
p = 0.1 )
g.s <- sample_smallworld(dim = 1, # one dimension (all nodes are around a circle)
size = n,
nei = round(deg/2), # neighbourhood is c/2 in both ways so c in total
p = 0.1 )
mean(degree(g.s))
mean_distance(g.s, directed = FALSE, unconnected = FALSE)
transitivity(g.s)
K <- matrix(NA, nrow = 1000, ncol = 3)
colnames(K) <- c("s.p", "s.l", "s.t")
K <- matrix(NA, nrow = 1000, ncol = 3)
colnames(K) <- c("Rewiring Probability", "Mean Distance", "Clustering Coefficient")
K <- matrix(NA, nrow = 1000, ncol = 3)
colnames(K) <- c("Rewiring Probability", "Mean Distance", "Clustering Coefficient")
for (i in 1:1000) {
#(i/2)/1000 = p (rewiring probability) that we will increase
#incrementally as i grows in the loop
g.s <- sample_smallworld(1, n, round(c/2), (i/2)/1000)
K[i,1] <- (i/2)/1000
K[i,2] <- mean_distance(g.s, directed = FALSE, unconnected = FALSE)
K[i,3] <- transitivity(g.s)
}
K <- matrix(NA, nrow = 1000, ncol = 3)
colnames(K) <- c("Rewiring Probability", "Mean Distance", "Clustering Coefficient")
for (i in 1:1000) {
#(i/2)/1000 = p (rewiring probability) that we will increase
#incrementally as i grows in the loop
g.s <- sample_smallworld(1, n, round(c/2), (i/2)/1000)
K[i,1] <- (i/2)/1000
K[i,2] <- mean_distance(g.s, directed = FALSE, unconnected = FALSE)
K[i,3] <- transitivity(g.s)
}
for (i in 1:1000) {
g.s <- sample_smallworld(1, n, round(c/2), (i/2)/1000)
K[i,1] <- (i/2)/1000
K[i,2] <- mean_distance(g.s, directed = FALSE, unconnected = FALSE)
K[i,3] <- transitivity(g.s)
}
for (i in 1:1000) {
g.s <- sample_smallworld(1, n, round(deg/2), (i/2)/1000)
K[i,1] <- (i/2)/1000
K[i,2] <- mean_distance(g.s, directed = FALSE, unconnected = FALSE)
K[i,3] <- transitivity(g.s)
}
K <- matrix(NA, nrow = 1000, ncol = 3)
colnames(K) <- c("Rewiring Probability", "Mean Distance", "Clustering Coefficient")
for (i in 1:1000) {
g.s <- sample_smallworld(1, n, round(deg/2), (i/2)/1000)
K[i,1] <- (i/2)/1000
K[i,2] <- mean_distance(g.s, directed = FALSE, unconnected = FALSE)
K[i,3] <- transitivity(g.s)
}
par(mfrow=c(1,2))
plot(K[,1],K[,2], xlab = "p", ylab="mean distance")
plot(K[,1],K[,3], xlab = "p", ylab="Clustering coeff")
g.x <- graph( c(1,2 ,1,4, 2,4, 3,4, 4,7, 5,7,
7,9, 8,9, 8,10, 9,10), directed=FALSE )
set.seed(1234) ## set the seed in my original drawing, otherwise the nodes will float around
plot(g.x)
table(degree(g.x))
degree_distribution(g.x)
degree_distribution(g.x, cumulative = TRUE)
par(mfrow=c(1,2))
plot(c(0:4), degree_distribution(g.x, cumulative = FALSE),
type = "b", main ="Degree distribution",
xlab="Degree", ylab ="p(degree)" )
plot(c(0:4), degree_distribution(g.x, cumulative = TRUE),
type = "b", main = "Cumulative degree distribution",
xlab="Degree", ylab ="p(degree)>x" )
